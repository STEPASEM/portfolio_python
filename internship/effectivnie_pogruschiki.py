"""
ГОД: 2025
На крупном заводе решили проверить эффективность работы погрузчиков и провели эксперимент: установили на складах датчики iBeacon и отслеживали перемещение погрузчиков между различными зонами.
Каждая зона склада обозначается уникальным целым числом. Когда погрузчик перемещается из одной зоны в другую, система регистрирует номер новой зоны, в которую он въехал. В результате движение каждого погрузчика представлено в виде последовательности чисел.
Инженеры завода считают, что наиболее эффективный путь, который может совершить погрузчик, — это поездка из некоторой начальной зоны в конечную, а затем возвращение по тому же маршруту обратно. Такая последовательность перемещений формирует так называемый «идеальный маршрут».
Вам необходимо найти длину самого длинного «идеального маршрута» в записи перемещений погрузчика.

Формат ввода

Первая строка содержит одно целое число n (1 ≤ n ≤ 100) — количество записей о перемещениях погрузчика.
Вторая строка содержит n целых чисел a₁, a₂, ..., aₙ (1 ≤ ai ≤ 10 9) — последовательность зон, через которые проехал погрузчик.

Формат вывода

Выведите одно целое число — длину самого длинного «идеального маршрута» в записи перемещений. Если такого маршрута не существует, выведите 0.
Пример 1
Ввод	Вывод
7
1 2 3 4 3 2 1

7
Пример 2
Ввод	Вывод
5
1 2 3 4 5

0
Пример 3
Ввод	Вывод
10
1 2 3 4 5 5 4 3 2 1

10
Пример 4
Ввод	Вывод
6
1 2 3 1 2 3

0"""

n = int(input())
a = list(map(int, input().split()))
max_len = 0


# Функция для поиска максимального палиндрома
def longest_palindrome(arr):
    max_length = 1
    start = 0

    for i in range(1, len(arr)):
        # Проверяем палиндромы нечётной длины
        low = i - 1
        high = i + 1
        while low >= 0 and high < len(arr) and arr[low] == arr[high]:
            if high - low + 1 > max_length:
                max_length = high - low + 1
            low -= 1
            high += 1

        # Проверяем палиндромы чётной длины
        low = i - 1
        high = i
        while low >= 0 and high < len(arr) and arr[low] == arr[high]:
            if high - low + 1 > max_length:
                max_length = high - low + 1
            low -= 1
            high += 1

    return max_length


max_palindrome = longest_palindrome(a)

# Проверяем, можно ли считать этот палиндром "идеальным маршрутом"
if max_palindrome > 1:
    print(max_palindrome)
else:
    print(0)